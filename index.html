<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loan Bubble Graph - Corrected with Dense Overlaps</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .wallet-selector {
            margin: 20px auto;
            padding: 8px;
            width: 300px;
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #221E37;
            color: #B6B1D5;
        }
        .app {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 24px;
            gap: 24px;
            width: 100%;
            max-width: 1200px;
            background: #221E37;
            box-shadow: 0px 0px 2px rgba(0, 0, 0, 0.24), 0px 12px 24px -4px rgba(0, 0, 0, 0.24);
            border-radius: 16px;
            margin: 20px auto;
            box-sizing: border-box;
        }
        .chart-wrapper {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            padding: 12px 0px 0px 0px;
            width: 100%;
            height: 365px;
            position: relative;
        }
        canvas {
            display: block;
            margin: 0;
            border: none;
            position: relative;
            z-index: 1;
            border-radius: 8px;
            width: 100%;
            height: 100%;
        }
        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #tooltip {
            position: absolute;
            min-width: 320px;
            max-width: 340px;
            background: #332C4B;
            color: #fff;
            border-radius: 20px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.18);
            padding: 24px 24px 20px 24px;
            font-family: 'Inter', Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
            visibility: hidden;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 4px;
            border: none;
            transition: opacity 0.2s;
        }
        #tooltip .tooltip-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 8px;
        }
        #tooltip .tooltip-img {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #3ED6B7;
            object-fit: cover;
            border: 4px solid #221E37;
        }
        #tooltip .tooltip-title {
            font-size: 22px;
            font-weight: 600;
            color: #fff;
            margin: 0;
            line-height: 1.2;
        }
        #tooltip .tooltip-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 0 0 2px 0;
        }
        #tooltip .tooltip-label {
            color: hsl(0, 0%, 68%);
            font-size: 14px;
            font-weight: 500;
            
        }
        #tooltip .tooltip-value {
            color: #fff;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 0.04em;
        }
        #tooltip .tooltip-value.usdc {
            font-size: 18px;
            font-weight: 700;
            color: #fff;
            margin-left: 4px;
        }
        .axis-label {
            position: absolute;
            font-size: 14px;
            color: #333;
        }
        .x-axis-label {
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
        }
        .y-axis-label {
            left: -40px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
        }
    </style>
</head>
<body>
    <select id="walletSelect" class="wallet-selector">
        <option value="">Select a wallet...</option>
    </select>
    <div class="app">
        <div class="chart-wrapper">
            <canvas id="canvas"></canvas>
            <div id="tooltip"></div>
        </div>
    </div>
    <script>
    // --- DOM and Canvas Setup ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');

    // --- Layout Constants ---
    let WIDTH = canvas.width;
    let HEIGHT = canvas.height;
    let CHART_HEIGHT = Math.round(HEIGHT * 0.88); // Reduce plot area to leave space for x-axis labels
    let CHART_PADDING_X = 24; // 24px left padding for y-axis
    let CHART_PADDING_TOP = Math.round(HEIGHT * 0.03); // 3% top padding
    let CHART_PADDING_BOTTOM = Math.round(HEIGHT * 0.09); // 9% bottom padding for x-axis labels

    // --- Axis and Tick Constants ---
    const DATE_FORMAT = { month: 'short', day: 'numeric' };
    const GRID_LINE_COLOR = '#ddd';
    const AXIS_LINE_COLOR = '#666';
    const TICK_LENGTH = 5;
    const TICK_PADDING = 5;
    const DATE_TICK_COUNT = 12; // Number of date ticks to show

    // --- Data Padding and Bubble Sizing ---
    const MIN_PADDING_PERCENT = 0.05;  // Minimum 5% padding
    const MAX_PADDING_PERCENT = 0.1;   // Maximum 10% padding
    const BUBBLE_PADDING_FACTOR = 1.2; // Add 20% extra space for bubble radius

    // --- Physics and Force Constants ---
    const BASE_VELOCITY = 0.2;                    // Base velocity for initial bubble movement
    const VELOCITY_POWER = 0.9;                   // How aggressively velocity scales with cluster size
    const OVERLAP_SCALE = 0.3;                    // How strongly overlapping bubbles push apart
    const CLUSTER_SCALE_DIVISOR = 3;              // How much cluster size affects spring force
    const OVERLAP_FORCE_MULTIPLIER = 3;           // How much stronger the force is when bubbles overlap
    const BASE_REPULSION = 0.0065;                // Base strength of repulsion between bubbles
    const REPULSION_POWER = 2;                  // How aggressively repulsion scales with cluster size
    const OUTWARD_FORCE_DIVISOR = 3;              // How much cluster size affects outward force
    const OUTWARD_FORCE_POWER = 2;              // How aggressively outward force scales with cluster size

    // --- Physics Settings ---
    const SPRING_CONSTANT = 0.008;
    const DAMPING = 0.75;
    const OUTWARD_FORCE = 0.004;
    const MAX_FRAMES = 60;
    const REVERT_DELAY = 2000;
    const REVERT_SPEED = 0.15;

    // --- Data State ---
    const allBubbles = [];
    const clusters = [];
    const singleBubbles = [];
    let mouseX = 0;
    let mouseY = 0;
    let PADDED_MIN_DATE = null;
    let PADDED_MAX_DATE = null;

    // Wallet addresses
    const WALLETS = [
        "0x148216a1800ab3d71668b4126b4244a9a909955f",
        "0x2f44fb58135ae5d3793803c73d471c7cde4bb774",
        "0x7a65cd0ad11e7329f534b5b65113997cf75e3546",
        "0xe90f08ddfa43c52149e4049d09c02919c797ed2a",
        "0x94de7e2c73529ebf3206aa3459e699fbcdfcd49b",
        "0x1e8fd4c82adae5aeeafca2df14252d1610322179",
        "0xd876f7215aaa80272b52eccdbf30e949eec13292",
        "0xcffc336e6d019c1af58257a0b10bf2146a3f42a4",
        "0x6358869f958ecdd132f5da7937264de46e54483c",
        "0x1da5331994e781ab0e2af9f85bfce2037a514170"
    ];

    // Add protocol color mapping at the top of the script
    const PROTOCOL_COLORS = {
        'NFTfi': '#D14D8A',
        'Gondi': '#FFE082',
        'X2Y2': '#D1A06F',
        'Zharta': '#5EC6A6',
        'Arcade': '#5B8DB8',
        'Metastreet': '#A3C8F5',
        'Blend': '#B18CFF'
    };
    const DEFAULT_PROTOCOL_COLOR = '#888888';

    // Populate wallet dropdown
    const walletSelect = document.getElementById('walletSelect');
    WALLETS.forEach((wallet, index) => {
        const option = document.createElement('option');
        option.value = wallet;
        option.textContent = `Wallet ${index + 1}`;
        walletSelect.appendChild(option);
    });
    // Set default wallet (index 7 is wallet 8)
    walletSelect.value = WALLETS[7];
    // Trigger initial load
    fetchLoanData(WALLETS[7]).then(data => {
        if (data && data.data && data.data.length > 0) {
            useLoanDataForBubbles(data.data);
        }
    });

    // API call function
    async function fetchLoanData(walletAddress) {
        try {
            const response = await fetch(`https://theta-sdk-api.nftfi.com/data/v0/pipes/loans_due_endpoint.json?daysFromNow=30&page_size=1000000&borrowerAddress=${walletAddress}&page=0`);
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching loan data:', error);
            return null;
        }
    }

    // --- Create Loan Bubble from API Data ---
    function createLoanBubbleFromAPI(loan, minAPR, maxAPR, minDue, maxDue, minUSD, maxUSD) {
        // Calculate base position with padding
        let x = CHART_PADDING_X + (WIDTH - 2 * CHART_PADDING_X) * (loan.apr - minAPR) / ((maxAPR - minAPR) || 1);
        let y = CHART_PADDING_TOP + (CHART_HEIGHT - CHART_PADDING_TOP) * (new Date(loan.dueTime).getTime() - minDue) / ((maxDue - minDue) || 1);
        
        // Add tiny random offset (5-10 pixels)
        x += (Math.random() - 0.5) * 10;
        y += (Math.random() - 0.5) * 10;
        
        // Calculate radius
        let r = 10 + ((loan.principalAmountUSD - minUSD) / ((maxUSD - minUSD) || 1)) * (40 - 10);
        r = Math.max(10, Math.min(40, r));
        
        // Clamp to canvas with bubble radius consideration
        const minX = CHART_PADDING_X + r * BUBBLE_PADDING_FACTOR;
        const maxX = WIDTH - CHART_PADDING_X - (r * BUBBLE_PADDING_FACTOR);
        const minY = CHART_PADDING_TOP + r * BUBBLE_PADDING_FACTOR;
        const maxY = CHART_HEIGHT - (r * BUBBLE_PADDING_FACTOR);
        
        x = Math.max(minX, Math.min(maxX, x));
        y = Math.max(minY, Math.min(maxY, y));
        
        return {
            x, y, r,
            initialX: x, initialY: y,
            vx: (Math.random() - 0.5) * 0.1,
            vy: (Math.random() - 0.5) * 0.1,
            repayment: loan.maximumRepaymentAmountUSD,
            apr: loan.apr,
            loanAmount: loan.principalAmountUSD,
            dueTime: loan.dueTime, // Store the due time for date calculations
            name: loan.nftName || loan.nftProjectName || 'NFT Loan',
            imageUrl: loan.nftImageSmallUri || loan.nftImageLargeUri || loan.nftProjectImageUri || 'https://via.placeholder.com/56x56.png?text=NFT',
            showTooltip: true,
            visited: false,
            protocol: loan.protocolName || ''
        };
    }

    // --- Use loan data for bubbles ---
    function useLoanDataForBubbles(loans) {
        allBubbles.length = 0;
        clusters.length = 0;
        singleBubbles.length = 0;

        if (!loans || loans.length === 0) return;

        // Calculate min/max for mapping
        const minAPR = Math.min(...loans.map(l => l.apr));
        const maxAPR = Math.max(...loans.map(l => l.apr));
        const minDue = Math.min(...loans.map(l => new Date(l.dueTime).getTime()));
        const maxDue = Math.max(...loans.map(l => new Date(l.dueTime).getTime()));
        const minUSD = Math.min(...loans.map(l => l.principalAmountUSD));
        const maxUSD = Math.max(...loans.map(l => l.principalAmountUSD));

        // Calculate dynamic padding based on data range
        const aprRange = maxAPR - minAPR;
        const dueRange = maxDue - minDue;
        
        // Calculate padding as percentage of range, but keep it within bounds
        const aprPadding = Math.min(Math.max(aprRange * MIN_PADDING_PERCENT, aprRange * MAX_PADDING_PERCENT), aprRange * MAX_PADDING_PERCENT);
        const duePadding = Math.min(Math.max(dueRange * MIN_PADDING_PERCENT, dueRange * MAX_PADDING_PERCENT), dueRange * MAX_PADDING_PERCENT);

        // Adjust min/max with padding
        const paddedMinAPR = minAPR - aprPadding;
        const paddedMaxAPR = maxAPR + aprPadding;
        const paddedMinDue = minDue - duePadding;
        const paddedMaxDue = maxDue + duePadding;

        // Store globally for axis drawing
        PADDED_MIN_DATE = paddedMinDue;
        PADDED_MAX_DATE = paddedMaxDue;

        for (const loan of loans) {
            allBubbles.push(createLoanBubbleFromAPI(loan, paddedMinAPR, paddedMaxAPR, paddedMinDue, paddedMaxDue, minUSD, maxUSD));
        }
        findClusters(allBubbles);
    }

    // --- Detect Overlaps and Form Clusters ---
    function bubblesOverlap(b1, b2) {
        const dx = b1.x - b2.x;
        const dy = b1.y - b2.y;
        const dist = Math.hypot(dx, dy);
        return dist < (b1.r + b2.r) * 0.98;
    }

    function findClusters(bubbles) {
        const visited = new Set();
        const clusterMap = new Map();
        
        // First pass: find all clusters and their sizes
        for (const b of bubbles) {
            if (visited.has(b)) continue;

            const cluster = [];
            const queue = [b];
            visited.add(b);

            while (queue.length > 0) {
                const current = queue.pop();
                cluster.push(current);

                for (const other of bubbles) {
                    if (!visited.has(other) && bubblesOverlap(current, other)) {
                        visited.add(other);
                        queue.push(other);
                    }
                }
            }

            const clusterSize = cluster.length;
            for (const bubble of cluster) {
                clusterMap.set(bubble, clusterSize);
            }

            if (clusterSize > 1) {
                clusters.push({ 
                    bubbles: cluster, 
                    state: "idle", 
                    hovering: false, 
                    revertTimer: null, 
                    frameCount: 0,
                    size: clusterSize
                });
            } else {
                singleBubbles.push(cluster[0]);
            }
        }

        // Second pass: update initial velocities based on cluster size
        for (const b of bubbles) {
            const clusterSize = clusterMap.get(b) || 1;
            const velocityScale = Math.pow(clusterSize, VELOCITY_POWER);
            const angle = Math.random() * Math.PI * 2;
            
            b.vx = Math.cos(angle) * BASE_VELOCITY * velocityScale;
            b.vy = Math.sin(angle) * BASE_VELOCITY * velocityScale;
        }
    }

    // Add this function to measure overlap between two bubbles
    function getBubbleOverlap(b1, b2) {
        const dx = b1.x - b2.x;
        const dy = b1.y - b2.y;
        const dist = Math.hypot(dx, dy);
        const overlap = (b1.r + b2.r) - dist;
        return overlap;
    }

    // --- Physics Functions ---
    function applySpringForces(cluster) {
        const bubbles = cluster.bubbles;
        const clusterSize = cluster.size;
        // Calculate overlap counts for each bubble
        const overlapCounts = new Map();
        for (let i = 0; i < bubbles.length; i++) {
            let overlaps = 0;
            for (let j = 0; j < bubbles.length; j++) {
                if (i !== j && getBubbleOverlap(bubbles[i], bubbles[j]) > 0.1 * (bubbles[i].r + bubbles[j].r)) {
                    overlaps++;
                }
            }
            overlapCounts.set(bubbles[i], overlaps);
        }
        // --- Always apply spring/attraction force to all pairs ---
        for (let i = 0; i < bubbles.length; i++) {
            for (let j = i + 1; j < bubbles.length; j++) {
                const ci = bubbles[i];
                const cj = bubbles[j];
                const dx = cj.x - ci.x;
                const dy = cj.y - ci.y;
                const dist = Math.hypot(dx, dy) || 1e-6;
                const idealDist = ci.r + cj.r;
                const displacement = dist - idealDist;
                const overlapScale = 1 + (overlapCounts.get(ci) + overlapCounts.get(cj)) * OVERLAP_SCALE;
                const clusterScale = 1 + (clusterSize / CLUSTER_SCALE_DIVISOR);
                const springVariation = 1 + (Math.random() - 0.5) * 0.1;
                let force = SPRING_CONSTANT * displacement * overlapScale * clusterScale * springVariation;
                // Only boost force for overlapping pairs
                if (displacement < 0 && getBubbleOverlap(ci, cj) > 0.1 * (ci.r + cj.r)) {
                    force *= OVERLAP_FORCE_MULTIPLIER;
                }
                const nx = dx / dist;
                const ny = dy / dist;
                ci.vx += nx * force;
                ci.vy += ny * force;
                cj.vx -= nx * force;
                cj.vy -= ny * force;
            }
        }
        // --- Repulsion only for pairs with >10% overlap ---
        const repulsionForce = BASE_REPULSION * Math.pow(clusterSize, REPULSION_POWER);
        for (let i = 0; i < bubbles.length; i++) {
            for (let j = i + 1; j < bubbles.length; j++) {
                const ci = bubbles[i];
                const cj = bubbles[j];
                const overlap = getBubbleOverlap(ci, cj);
                if (overlap > 0.1 * (ci.r + cj.r)) {
                    const dx = cj.x - ci.x;
                    const dy = cj.y - ci.y;
                    const dist = Math.hypot(dx, dy) || 1e-6;
                    const nx = dx / dist;
                    const ny = dy / dist;
                    ci.vx -= nx * repulsionForce;
                    ci.vy -= ny * repulsionForce;
                    cj.vx += nx * repulsionForce;
                    cj.vy += ny * repulsionForce;
                }
            }
        }
    }

    function updateCluster(cluster) {
        const bubbles = cluster.bubbles;
        for (const c of bubbles) {
            c.x += c.vx;
            c.y += c.vy;
            c.vx *= DAMPING;
            c.vy *= DAMPING;
        }
    }

    function applyOutwardForce(cluster) {
        const centerX = WIDTH / 2;
        const centerY = HEIGHT / 2;
        const clusterSize = cluster.size;
        const outwardForce = OUTWARD_FORCE * (1 + Math.pow(clusterSize, OUTWARD_FORCE_POWER) / OUTWARD_FORCE_DIVISOR);
        
        for (const c of cluster.bubbles) {
            const dx = c.x - centerX;
            const dy = c.y - centerY;
            const dist = Math.hypot(dx, dy) || 1e-6;
            c.vx += (dx / dist) * outwardForce;
            c.vy += (dy / dist) * outwardForce;
        }
    }

    function revertClusterSmoothly(cluster) {
        let allClose = true;
        for (const b of cluster.bubbles) {
            b.x += (b.initialX - b.x) * REVERT_SPEED;
            b.y += (b.initialY - b.y) * REVERT_SPEED;

            const dx = b.x - b.initialX;
            const dy = b.y - b.initialY;
            if (Math.abs(dx) > 0.5 || Math.abs(dy) > 0.5) {
                allClose = false;
            }
        }

        if (allClose) {
            for (const b of cluster.bubbles) {
                b.x = b.initialX;
                b.y = b.initialY;
                b.vx = 0;
                b.vy = 0;
                b.showTooltip = false;
            }
            cluster.state = "idle";
            cluster.frameCount = 0;
        }
    }

    // --- D3-inspired time scale and tick generator ---
    function timeScale(domain, range) {
        const [d0, d1] = domain;
        const [r0, r1] = range;
        return d => r0 + ((d - d0) / (d1 - d0)) * (r1 - r0);
    }

    // Returns an array of Date objects for nice ticks, adapting to the span
    function niceDateTicks(start, stop, maxCount) {
        const msSecond = 1000;
        const msMinute = 60 * msSecond;
        const msHour = 60 * msMinute;
        const msDay = 24 * msHour;
        const msWeek = 7 * msDay;
        const msMonth = msDay * 30;
        const msYear = msDay * 365;
        const span = stop - start;
        let step, unit, format;
        if (span < msHour * 12) {
            step = Math.ceil(span / msHour / maxCount);
            unit = 'hour';
            format = d => d.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit'});
        } else if (span < msDay * 2) {
            step = Math.ceil(span / msHour / maxCount);
            unit = 'hour';
            format = d => d.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit'});
        } else if (span < msWeek * 2) {
            step = Math.ceil(span / msDay / maxCount);
            unit = 'day';
            format = d => d.toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
        } else if (span < msMonth * 2) {
            step = Math.ceil(span / msDay / maxCount * 2);
            unit = 'day';
            format = d => d.toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
        } else if (span < msYear) {
            step = Math.ceil(span / msMonth / maxCount);
            unit = 'month';
            format = d => d.toLocaleDateString('en-US', {month: 'short', year: '2-digit'});
        } else {
            step = Math.ceil(span / msYear / maxCount);
            unit = 'year';
            format = d => d.getFullYear();
        }
        const ticks = [];
        let d = new Date(start);
        d.setSeconds(0,0);
        d.setMinutes(0);
        d.setHours(0);
        if (unit === 'month') d.setDate(1);
        if (unit === 'year') { d.setMonth(0); d.setDate(1); }
        while (d.getTime() < stop) {
            ticks.push(new Date(d));
            if (unit === 'year') d.setFullYear(d.getFullYear() + step);
            else if (unit === 'month') d.setMonth(d.getMonth() + step);
            else if (unit === 'week') d.setDate(d.getDate() + 7 * step);
            else if (unit === 'day') d.setDate(d.getDate() + step);
            else if (unit === 'hour') d.setHours(d.getHours() + step);
        }
        if (ticks.length < 2 || ticks[ticks.length-1].getTime() < stop) {
            ticks.push(new Date(stop));
        }
        return {ticks, format};
    }

    // --- D3-inspired linear tick generator for APR ---
    function niceLinearTicks(min, max, maxCount) {
        // D3-like nice ticks for linear scale
        const span = max - min;
        if (span === 0) return [min];
        const step = Math.pow(10, Math.floor(Math.log10(span / maxCount)));
        const err = maxCount / (span / step);
        let niceStep = step;
        if (err <= 0.15) niceStep *= 10;
        else if (err <= 0.35) niceStep *= 5;
        else if (err <= 0.75) niceStep *= 2;
        const niceMin = Math.floor(min / niceStep) * niceStep;
        const niceMax = Math.ceil(max / niceStep) * niceStep;
        const ticks = [];
        for (let v = niceMin; v <= niceMax + 0.5 * niceStep; v += niceStep) {
            ticks.push(Number(v.toFixed(6)));
        }
        return ticks;
    }

    // --- Draw Axes ---
    function drawAxes() {
        ctx.save();
        ctx.lineWidth = 1;
        
        // Draw Y axis APR ticks, grid lines, and labels (D3-inspired)
        if (allBubbles.length > 0) {
            const loans = allBubbles;
            const minAPR = Math.min(...loans.map(l => l.apr));
            const maxAPR = Math.max(...loans.map(l => l.apr));
            let aprTicks = niceLinearTicks(minAPR, maxAPR, 8);
            if (aprTicks.length > 1) aprTicks = aprTicks.slice(1);
            aprTicks.forEach(tick => {
                const y = CHART_PADDING_TOP + (CHART_HEIGHT - CHART_PADDING_TOP) * (1 - (tick - minAPR) / ((maxAPR - minAPR) || 1));
                // Draw grid line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; // semi-transparent white
                ctx.beginPath();
                ctx.moveTo(CHART_PADDING_X, y);
                ctx.lineTo(WIDTH, y);
                ctx.stroke();
                // Draw tick in left margin
                ctx.strokeStyle = '#B6B1D5'; // lighter color for axis
                ctx.beginPath();
                ctx.moveTo(CHART_PADDING_X - TICK_LENGTH, y);
                ctx.lineTo(CHART_PADDING_X, y);
                ctx.stroke();
                // Draw label in left margin
                ctx.fillStyle = '#B6B1D5'; // lighter color for labels
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.font = '13px Inter, Arial, sans-serif';
                ctx.fillText(tick % 1 === 0 ? `${tick}` : tick.toFixed(2), CHART_PADDING_X - TICK_LENGTH - TICK_PADDING, y);
            });
        }
        
        // Draw X axis date ticks and grid lines (D3-inspired)
        if (allBubbles.length > 0 && PADDED_MIN_DATE !== null && PADDED_MAX_DATE !== null) {
            const paddedMinDate = PADDED_MIN_DATE;
            const paddedMaxDate = PADDED_MAX_DATE;
            const scale = timeScale([paddedMinDate, paddedMaxDate], [CHART_PADDING_X, WIDTH - CHART_PADDING_X]);
            const {ticks: dateTicks, format: dateFormat} = niceDateTicks(paddedMinDate, paddedMaxDate, DATE_TICK_COUNT);
            dateTicks.forEach(date => {
                const x = scale(date.getTime());
                // Draw grid line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; // semi-transparent white
                ctx.beginPath();
                ctx.moveTo(x, CHART_PADDING_TOP);
                ctx.lineTo(x, CHART_HEIGHT);
                ctx.stroke();
                // Draw tick
                ctx.strokeStyle = '#B6B1D5'; // lighter color for axis
                ctx.beginPath();
                ctx.moveTo(x, CHART_HEIGHT);
                ctx.lineTo(x, CHART_HEIGHT + TICK_LENGTH);
                ctx.stroke();
                // Draw date label in the dark area, above the bottom padding
                ctx.fillStyle = '#B6B1D5'; // lighter color for labels
                ctx.textAlign = 'center';
                const dateStr = dateFormat(date);
                ctx.fillText(dateStr, x, CHART_HEIGHT + TICK_LENGTH + TICK_PADDING + 10);
            });
        }
        
        ctx.restore();
    }

    // --- Draw Function ---
    function draw() {
        // Visually separate plot and label areas
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        // Draw top margin (dark for top padding)
        ctx.fillStyle = '#221E37';
        ctx.fillRect(0, 0, WIDTH, CHART_PADDING_TOP);
        // Draw left margin (dark for y-axis labels)
        ctx.fillStyle = '#221E37';
        ctx.fillRect(0, CHART_PADDING_TOP, CHART_PADDING_X, CHART_HEIGHT - CHART_PADDING_TOP);
        // Draw label area (dark)
        ctx.fillStyle = '#221E37';
        ctx.fillRect(0, CHART_HEIGHT, WIDTH, HEIGHT - CHART_HEIGHT);
        // Draw plot area (dark), starting exactly at the y-axis line
        ctx.fillStyle = '#221E37';
        ctx.fillRect(CHART_PADDING_X - TICK_LENGTH, CHART_PADDING_TOP, WIDTH - (CHART_PADDING_X - TICK_LENGTH), CHART_HEIGHT - CHART_PADDING_TOP);
        // Draw axes and bubbles
        drawAxes();
        for (const b of singleBubbles) {
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
            ctx.fillStyle = PROTOCOL_COLORS[b.protocol] || DEFAULT_PROTOCOL_COLOR;
            ctx.globalAlpha = 0.65;
            ctx.fill();
            ctx.globalAlpha = 1.0;
            ctx.strokeStyle = 'rgba(0,0,0,0)'; // no outline
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        for (const cluster of clusters) {
            for (const b of cluster.bubbles) {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                ctx.fillStyle = PROTOCOL_COLORS[b.protocol] || DEFAULT_PROTOCOL_COLOR;
                ctx.globalAlpha = 0.65;
                ctx.fill();
                ctx.globalAlpha = 1.0;
                ctx.setLineDash([6, 6]);
                ctx.strokeStyle = 'rgba(255,255,255,0.75)'; // dashed white outline
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.setLineDash([]);
            }
        }
    }

    // --- Mouse Handling ---
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;

        for (const cluster of clusters) {
            let hovering = false;
            for (const b of cluster.bubbles) {
                const dx = mouseX - b.x;
                const dy = mouseY - b.y;
                const dist = Math.hypot(dx, dy);
                if (dist < b.r) {
                    hovering = true;
                    break;
                }
            }

            if (hovering) {
                cluster.hovering = true;
                if (cluster.state === "idle") {
                    cluster.state = "expanding";
                    applyOutwardForce(cluster);
                    cluster.frameCount = 0;
                }
                if (cluster.revertTimer) {
                    clearTimeout(cluster.revertTimer);
                    cluster.revertTimer = null;
                }
            } else {
                if (cluster.hovering) {
                    cluster.hovering = false;
                    if (!cluster.revertTimer) {
                        cluster.revertTimer = setTimeout(() => {
                            if (!cluster.hovering) {
                                cluster.state = "reverting";
                            }
                        }, REVERT_DELAY);
                    }
                }
            }
        }
    });

    // --- Tooltip update ---
    function updateTooltip() {
        let closest = null;
        let closestDist = Infinity;

        for (const b of singleBubbles) {
            const dx = mouseX - b.x;
            const dy = mouseY - b.y;
            const dist = Math.hypot(dx, dy);
            if (dist < b.r && dist < closestDist && b.showTooltip) {
                closest = b;
                closestDist = dist;
            }
        }
        for (const cluster of clusters) {
            for (const b of cluster.bubbles) {
                const dx = mouseX - b.x;
                const dy = mouseY - b.y;
                const dist = Math.hypot(dx, dy);
                if (dist < b.r && dist < closestDist && b.showTooltip) {
                    closest = b;
                    closestDist = dist;
                }
            }
        }
        if (closest) {
            // Format expiry
            let expiry = '';
            if (closest.dueTime) {
                const d = new Date(closest.dueTime);
                expiry = d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
            }
            // Format repayment
            const repayment = closest.repayment ? closest.repayment.toLocaleString() : '';
            // Build HTML
            tooltip.innerHTML = `
                <div class="tooltip-header">
                    <img class="tooltip-img" src="${closest.imageUrl}" alt="NFT" />
                    <div class="tooltip-title">${closest.name || 'NFT Loan'}</div>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Protocol</span>
                    <span class="tooltip-value">${closest.protocol || 'Unknown'}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">APR</span>
                    <span class="tooltip-value">${closest.apr ? closest.apr.toFixed(2) : '--'}%</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Repayment</span>
                    <span class="tooltip-value">${repayment} <span class="tooltip-value usdc">USDC</span></span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Expiry</span>
                    <span class="tooltip-value">${expiry}</span>
                </div>
            `;
            tooltip.style.left = (closest.x + canvas.offsetLeft + 20) + "px";
            tooltip.style.top = (closest.y + canvas.offsetTop - 40) + "px";
            tooltip.style.visibility = "visible";
        } else {
            tooltip.style.visibility = "hidden";
        }
    }

    // --- Update wallet selection event to use new bubbles ---
    walletSelect.addEventListener('change', async (e) => {
        const selectedWallet = e.target.value;
        if (selectedWallet) {
            const data = await fetchLoanData(selectedWallet);
            if (data && data.data && data.data.length > 0) {
                useLoanDataForBubbles(data.data);
            }
        }
    });

    // Animation loop
    function animate() {
        for (const cluster of clusters) {
            if (cluster.state === "expanding") {
                applySpringForces(cluster);
                updateCluster(cluster);
                cluster.frameCount++;
                if (cluster.frameCount >= MAX_FRAMES) {
                    cluster.state = "expanded";
                    for (const b of cluster.bubbles) {
                        b.showTooltip = true;
                    }
                }
            } else if (cluster.state === "reverting") {
                revertClusterSmoothly(cluster);
            }
        }

        draw();
        updateTooltip();
        requestAnimationFrame(animate);
    }

    // Start animation
    animate();

    // --- Responsive Resize Handler ---
    function resizeChart() {
        const container = document.querySelector('.chart-wrapper');
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(containerWidth * dpr);
        canvas.height = Math.round(containerHeight * dpr);
        canvas.style.width = containerWidth + 'px';
        canvas.style.height = containerHeight + 'px';
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        WIDTH = containerWidth;
        HEIGHT = containerHeight;
        CHART_HEIGHT = Math.round(HEIGHT * 0.88);
        CHART_PADDING_X = 24;
        CHART_PADDING_TOP = Math.round(HEIGHT * 0.03);
        CHART_PADDING_BOTTOM = Math.round(HEIGHT * 0.09);
        draw();
    }

    // Remove the aspect ratio function and use container dimensions
    window.addEventListener('resize', resizeChart);
    // Initial set
    resizeChart();

    // Add overlap stats to the animation loop for debugging
    function logOverlapStats() {
        let totalOverlap = 0;
        let maxOverlap = 0;
        let overlapCount = 0;
        for (let i = 0; i < allBubbles.length; i++) {
            for (let j = i + 1; j < allBubbles.length; j++) {
                const b1 = allBubbles[i];
                const b2 = allBubbles[j];
                const overlap = getBubbleOverlap(b1, b2);
                if (overlap > 0) {
                    totalOverlap += overlap;
                    maxOverlap = Math.max(maxOverlap, overlap);
                    overlapCount++;
                }
            }
        }
        console.log(`Total overlap: ${totalOverlap.toFixed(2)}, Max overlap: ${maxOverlap.toFixed(2)}, Overlapping pairs: ${overlapCount}`);
    }
    </script>
</body>
</html> 