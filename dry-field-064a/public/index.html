<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loan Bubble Graph - Corrected with Dense Overlaps</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            box-sizing: border-box;
        }
        .wallet-selector {
            margin: 20px auto;
            padding: 8px;
            width: 300px;
            font-size: 14px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            background: #221E37;
            color: #B6B1D5;
        }
        .app {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            padding: 24px;
            gap: 24px;
            width: 100%;
            max-width: 1200px;
            background: #221E37;
            box-shadow: 0px 0px 2px rgba(0, 0, 0, 0.24), 0px 12px 24px -4px rgba(0, 0, 0, 0.24);
            border-radius: 16px;
            margin: 20px auto;
            box-sizing: border-box;
        }
        .chart-wrapper {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            padding: 12px 0px 0px 0px;
            width: 100%;
            height: 365px;
            position: relative;
        }
        canvas {
            display: block;
            margin: 0;
            border: none;
            position: relative;
            z-index: 1;
            border-radius: 8px;
            width: 100%;
            height: 100%;
        }
        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid #ddd;
            border-radius: 4px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
        }
        #tooltip {
            position: absolute;
            min-width: 320px;
            max-width: 340px;
            background: #332C4B;
            color: #fff;
            border-radius: 20px;
            box-shadow: 0 4px 24px rgba(0,0,0,0.18);
            padding: 24px 24px 20px 24px;
            font-family: 'Inter', Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
            visibility: hidden;
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 4px;
            border: none;
            transition: opacity 0.2s;
        }
        #tooltip .tooltip-header {
            display: flex;
            align-items: center;
            gap: 16px;
            margin-bottom: 8px;
        }
        #tooltip .tooltip-img {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: #3ED6B7;
            object-fit: cover;
            border: 4px solid #221E37;
        }
        #tooltip .tooltip-title {
            font-size: 22px;
            font-weight: 600;
            color: #fff;
            margin: 0;
            line-height: 1.2;
        }
        #tooltip .tooltip-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 0 0 2px 0;
        }
        #tooltip .tooltip-label {
            color: hsl(0, 0%, 68%);
            font-size: 14px;
            font-weight: 500;
            
        }
        #tooltip .tooltip-value {
            color: #fff;
            font-size: 14px;
            font-weight: 700;
            letter-spacing: 0.04em;
        }
        #tooltip .tooltip-value.usdc {
            font-size: 18px;
            font-weight: 700;
            color: #fff;
            margin-left: 4px;
        }
        .axis-label {
            position: absolute;
            font-size: 14px;
            color: #333;
        }
        .x-axis-label {
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
        }
        .y-axis-label {
            left: -40px;
            top: 50%;
            transform: translateY(-50%) rotate(-90deg);
        }
    </style>
</head>
<body>
    <select id="walletSelect" class="wallet-selector">
        <option value="">Select a wallet...</option>
    </select>
    <div class="app">
        <div class="chart-wrapper">
            <canvas id="canvas"></canvas>
            <div id="tooltip"></div>
        </div>
    </div>
    <script type="module">
    import { createLoanBubbleFromAPI, useLoanDataForBubbles, findClusters } from './clusterUtils.js';
    import { getBubbleOverlap } from './bubbleUtils.js';
    import { applyOutwardForce, revertClusterSmoothly } from './physics.js';
    import { MAX_FRAMES, REVERT_DELAY } from './constants.js';
    // --- DOM and Canvas Setup ---
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const tooltip = document.getElementById('tooltip');

    // --- Layout Constants ---
    let WIDTH = canvas.width;
    let HEIGHT = canvas.height;
    let CHART_HEIGHT = Math.round(HEIGHT * 0.88); // Reduce plot area to leave space for x-axis labels
    let CHART_PADDING_X = 24; // 24px left padding for y-axis
    let CHART_PADDING_TOP = Math.round(HEIGHT * 0.03); // 3% top padding
    let CHART_PADDING_BOTTOM = Math.round(HEIGHT * 0.09); // 9% bottom padding for x-axis labels

    // --- Axis and Tick Constants ---
    const DATE_FORMAT = { month: 'short', day: 'numeric' };
    const GRID_LINE_COLOR = '#ddd';
    const AXIS_LINE_COLOR = '#666';
    const TICK_LENGTH = 5;
    const TICK_PADDING = 5;
    const DATE_TICK_COUNT = 12; // Number of date ticks to show

    // --- Data Padding and Bubble Sizing ---
    const MIN_PADDING_PERCENT = 0.05;  // Minimum 5% padding
    const MAX_PADDING_PERCENT = 0.1;   // Maximum 10% padding
    const BUBBLE_PADDING_FACTOR = 1.2; // Add 20% extra space for bubble radius
    const BASE_VELOCITY = 0.2;
    const VELOCITY_POWER = 0.9;

    // --- Data State ---
    const allBubbles = [];
    const clusters = [];
    const singleBubbles = [];
    let mouseX = 0;
    let mouseY = 0;
    let PADDED_MIN_DATE = null;
    let PADDED_MAX_DATE = null;

    // Wallet addresses
    const WALLETS = [
        "0xd79b937791724e47f193f67162b92cdfbf7abdfd",
        "0x1da5331994e781ab0e2af9f85bfce2037a514170",
        "0x6358869f958ecdd132f5da7937264de46e54483c",
        "0xcffc336e6d019c1af58257a0b10bf2146a3f42a4",
        "0xd876f7215aaa80272b52eccdbf30e949eec13292",
        "0x94de7e2c73529ebf3206aa3459e699fbcdfcd49b",
        "0x7a65cd0ad11e7329f534b5b65113997cf75e3546",
    ];

    // Add protocol color mapping at the top of the script
    const PROTOCOL_COLORS = {
        'NFTfi': '#D14D8A',
        'Gondi': '#FFE082',
        'X2Y2': '#D1A06F',
        'Zharta': '#5EC6A6',
        'Arcade': '#5B8DB8',
        'Metastreet': '#A3C8F5',
        'Blend': '#B18CFF'
    };
    const DEFAULT_PROTOCOL_COLOR = '#888888';

    // Populate wallet dropdown
    const walletSelect = document.getElementById('walletSelect');
    walletSelect.innerHTML = '<option value="">Select a wallet...</option>';
    WALLETS.forEach((wallet, index) => {
        const option = document.createElement('option');
        option.value = wallet;
        option.textContent = `Wallet ${index + 1}`;
        walletSelect.appendChild(option);
    });
    // Set default wallet (first in the new list)
    walletSelect.value = WALLETS[0];
    // Trigger initial load
    fetchLoanData(WALLETS[0]).then(data => {
        if (data && data.data && data.data.length > 0) {
            useLoanDataForBubbles(
                data.data,
                allBubbles,
                clusters,
                singleBubbles,
                clearChart,
                (bubbles) => findClusters(bubbles, clusters, singleBubbles, bubblesOverlap, VELOCITY_POWER, BASE_VELOCITY),
                (loan, ...bubbleArgs) => createLoanBubbleFromAPI(loan, ...bubbleArgs),
                (min, max) => { PADDED_MIN_DATE = min; PADDED_MAX_DATE = max; },
                MIN_PADDING_PERCENT,
                MAX_PADDING_PERCENT,
                CHART_PADDING_X,
                WIDTH,
                CHART_PADDING_TOP,
                CHART_HEIGHT,
                BUBBLE_PADDING_FACTOR
            );
        }
    });

    // API call function
    async function fetchLoanData(walletAddress) {
        try {
            const response = await fetch(`https://theta-sdk-api.nftfi.com/data/v0/pipes/loans_due_endpoint.json?daysFromNow=30&page_size=1000000&borrowerAddress=${walletAddress}&page=0`);
            const data = await response.json();
            return data;
        } catch (error) {
            console.error('Error fetching loan data:', error);
            return null;
        }
    }

    // --- Add a user-friendly message element above the chart ---
    if (!document.getElementById('no-data-message')) {
        const msg = document.createElement('div');
        msg.id = 'no-data-message';
        msg.style.display = 'none';
        msg.style.color = '#B6B1D5';
        msg.style.background = '#332C4B';
        msg.style.borderRadius = '12px';
        msg.style.padding = '16px 24px';
        msg.style.fontFamily = "'Inter', Arial, sans-serif";
        msg.style.fontSize = '18px';
        msg.style.textAlign = 'center';
        msg.style.margin = '16px auto 0 auto';
        msg.style.maxWidth = '600px';
        msg.innerText = 'No valid loans found for this wallet.';
        document.querySelector('.app').insertAdjacentElement('beforebegin', msg);
    }

    // --- Clear chart and state ---
    function clearChart() {
        allBubbles.length = 0;
        clusters.length = 0;
        singleBubbles.length = 0;
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        drawAxes();
        document.getElementById('no-data-message').style.display = 'block';
    }

    // --- Detect Overlaps and Form Clusters ---
    function bubblesOverlap(b1, b2) {
        const dx = b1.x - b2.x;
        const dy = b1.y - b2.y;
        const dist = Math.hypot(dx, dy);
        return dist < (b1.r + b2.r) * 0.98;
    }

    // --- D3-inspired time scale and tick generator ---
    function timeScale(domain, range) {
        const [d0, d1] = domain;
        const [r0, r1] = range;
        return d => r0 + ((d - d0) / (d1 - d0)) * (r1 - r0);
    }

    // Returns an array of Date objects for nice ticks, adapting to the span
    function niceDateTicks(start, stop, maxCount) {
        const msSecond = 1000;
        const msMinute = 60 * msSecond;
        const msHour = 60 * msMinute;
        const msDay = 24 * msHour;
        const msWeek = 7 * msDay;
        const msMonth = msDay * 30;
        const msYear = msDay * 365;
        const span = stop - start;
        let step, unit, format;
        if (span < msHour * 12) {
            step = Math.ceil(span / msHour / maxCount);
            unit = 'hour';
            format = d => d.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit'});
        } else if (span < msDay * 2) {
            step = Math.ceil(span / msHour / maxCount);
            unit = 'hour';
            format = d => d.toLocaleTimeString('en-US', {hour: '2-digit', minute: '2-digit'});
        } else if (span < msWeek * 2) {
            step = Math.ceil(span / msDay / maxCount);
            unit = 'day';
            format = d => d.toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
        } else if (span < msMonth * 2) {
            step = Math.ceil(span / msDay / maxCount * 2);
            unit = 'day';
            format = d => d.toLocaleDateString('en-US', {month: 'short', day: 'numeric'});
        } else if (span < msYear) {
            step = Math.ceil(span / msMonth / maxCount);
            unit = 'month';
            format = d => d.toLocaleDateString('en-US', {month: 'short', year: '2-digit'});
        } else {
            step = Math.ceil(span / msYear / maxCount);
            unit = 'year';
            format = d => d.getFullYear();
        }
        const ticks = [];
        let d = new Date(start);
        d.setSeconds(0,0);
        d.setMinutes(0);
        d.setHours(0);
        if (unit === 'month') d.setDate(1);
        if (unit === 'year') { d.setMonth(0); d.setDate(1); }
        while (d.getTime() < stop) {
            ticks.push(new Date(d));
            if (unit === 'year') d.setFullYear(d.getFullYear() + step);
            else if (unit === 'month') d.setMonth(d.getMonth() + step);
            else if (unit === 'week') d.setDate(d.getDate() + 7 * step);
            else if (unit === 'day') d.setDate(d.getDate() + step);
            else if (unit === 'hour') d.setHours(d.getHours() + step);
        }
        if (ticks.length < 2 || ticks[ticks.length-1].getTime() < stop) {
            ticks.push(new Date(stop));
        }
        return {ticks, format};
    }

    // --- D3-inspired linear tick generator for APR ---
    function niceLinearTicks(min, max, maxCount) {
        // D3-like nice ticks for linear scale
        const span = max - min;
        if (span === 0) return [min];
        const step = Math.pow(10, Math.floor(Math.log10(span / maxCount)));
        const err = maxCount / (span / step);
        let niceStep = step;
        if (err <= 0.15) niceStep *= 10;
        else if (err <= 0.35) niceStep *= 5;
        else if (err <= 0.75) niceStep *= 2;
        const niceMin = Math.floor(min / niceStep) * niceStep;
        const niceMax = Math.ceil(max / niceStep) * niceStep;
        const ticks = [];
        for (let v = niceMin; v <= niceMax + 0.5 * niceStep; v += niceStep) {
            ticks.push(Number(v.toFixed(6)));
        }
        return ticks;
    }

    // --- Draw Axes ---
    function drawAxes() {
        ctx.save();
        ctx.lineWidth = 1;
        
        // Draw Y axis APR ticks, grid lines, and labels (D3-inspired)
        if (allBubbles.length > 0) {
            const loans = allBubbles;
            const minAPR = Math.min(...loans.map(l => l.apr));
            const maxAPR = Math.max(...loans.map(l => l.apr));
            let aprTicks = niceLinearTicks(minAPR, maxAPR, 8);
            if (aprTicks.length > 1) aprTicks = aprTicks.slice(1);
            aprTicks.forEach(tick => {
                const y = CHART_PADDING_TOP + (CHART_HEIGHT - CHART_PADDING_TOP) * (1 - (tick - minAPR) / ((maxAPR - minAPR) || 1));
                // Draw grid line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; // semi-transparent white
                ctx.beginPath();
                ctx.moveTo(CHART_PADDING_X, y);
                ctx.lineTo(WIDTH, y);
                ctx.stroke();
                // Draw tick in left margin
                ctx.strokeStyle = '#B6B1D5'; // lighter color for axis
                ctx.beginPath();
                ctx.moveTo(CHART_PADDING_X - TICK_LENGTH, y);
                ctx.lineTo(CHART_PADDING_X, y);
                ctx.stroke();
                // Draw label in left margin
                ctx.fillStyle = '#B6B1D5'; // lighter color for labels
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.font = '13px Inter, Arial, sans-serif';
                ctx.fillText(tick % 1 === 0 ? `${tick}` : tick.toFixed(2), CHART_PADDING_X - TICK_LENGTH - TICK_PADDING, y);
            });
        }
        
        // Draw X axis date ticks and grid lines (D3-inspired)
        if (allBubbles.length > 0 && PADDED_MIN_DATE !== null && PADDED_MAX_DATE !== null) {
            const paddedMinDate = PADDED_MIN_DATE;
            const paddedMaxDate = PADDED_MAX_DATE;
            const scale = timeScale([paddedMinDate, paddedMaxDate], [CHART_PADDING_X, WIDTH - CHART_PADDING_X]);
            const {ticks: dateTicks, format: dateFormat} = niceDateTicks(paddedMinDate, paddedMaxDate, DATE_TICK_COUNT);
            dateTicks.forEach(date => {
                const x = scale(date.getTime());
                // Draw grid line
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)'; // semi-transparent white
                ctx.beginPath();
                ctx.moveTo(x, CHART_PADDING_TOP);
                ctx.lineTo(x, CHART_HEIGHT);
                ctx.stroke();
                // Draw tick
                ctx.strokeStyle = '#B6B1D5'; // lighter color for axis
                ctx.beginPath();
                ctx.moveTo(x, CHART_HEIGHT);
                ctx.lineTo(x, CHART_HEIGHT + TICK_LENGTH);
                ctx.stroke();
                // Draw date label in the dark area, above the bottom padding
                ctx.fillStyle = '#B6B1D5'; // lighter color for labels
                ctx.textAlign = 'center';
                const dateStr = dateFormat(date);
                ctx.fillText(dateStr, x, CHART_HEIGHT + TICK_LENGTH + TICK_PADDING + 10);
            });
        }
        
        ctx.restore();
    }

    // --- Draw Function ---
    function draw() {
        // Visually separate plot and label areas
        ctx.clearRect(0, 0, WIDTH, HEIGHT);
        // Draw top margin (dark for top padding)
        ctx.fillStyle = '#221E37';
        ctx.fillRect(0, 0, WIDTH, CHART_PADDING_TOP);
        // Draw left margin (dark for y-axis labels)
        ctx.fillStyle = '#221E37';
        ctx.fillRect(0, CHART_PADDING_TOP, CHART_PADDING_X, CHART_HEIGHT - CHART_PADDING_TOP);
        // Draw label area (dark)
        ctx.fillStyle = '#221E37';
        ctx.fillRect(0, CHART_HEIGHT, WIDTH, HEIGHT - CHART_HEIGHT);
        // Draw plot area (dark), starting exactly at the y-axis line
        ctx.fillStyle = '#221E37';
        ctx.fillRect(CHART_PADDING_X - TICK_LENGTH, CHART_PADDING_TOP, WIDTH - (CHART_PADDING_X - TICK_LENGTH), CHART_HEIGHT - CHART_PADDING_TOP);
        // Draw axes and bubbles
        drawAxes();
        // 1. Draw single bubbles and non-expanded clusters
        for (const b of singleBubbles) {
            ctx.beginPath();
            ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
            ctx.fillStyle = PROTOCOL_COLORS[b.protocol] || DEFAULT_PROTOCOL_COLOR;
            ctx.globalAlpha = 0.65;
            ctx.fill();
            ctx.globalAlpha = 1.0;
            ctx.strokeStyle = 'rgba(0,0,0,0)'; // no outline
            ctx.lineWidth = 1;
            ctx.stroke();
        }
        for (const cluster of clusters) {
            if (cluster.state !== "expanded" && cluster.state !== "expanding") {
                for (const b of cluster.bubbles) {
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                    ctx.fillStyle = PROTOCOL_COLORS[b.protocol] || DEFAULT_PROTOCOL_COLOR;
                    ctx.globalAlpha = 0.65;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r + 2, 0, Math.PI * 2); // 2px offset for stroke
                    ctx.strokeStyle = 'rgba(255,255,255,0.75)'; // dashed white outline
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        // 2. Draw expanded (and expanding) clusters on top
        for (const cluster of clusters) {
            if (cluster.state === "expanded" || cluster.state === "expanding") {
                for (const b of cluster.bubbles) {
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                    ctx.fillStyle = PROTOCOL_COLORS[b.protocol] || DEFAULT_PROTOCOL_COLOR;
                    ctx.globalAlpha = 0.65;
                    ctx.fill();
                    ctx.globalAlpha = 1.0;
                    ctx.setLineDash([6, 6]);
                    ctx.beginPath();
                    ctx.arc(b.x, b.y, b.r + 2, 0, Math.PI * 2); // 2px offset for stroke
                    ctx.strokeStyle = 'rgba(255,255,255,0.75)'; // dashed white outline
                    ctx.lineWidth = 1;
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
    }

    // --- Mouse Handling ---
    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        mouseX = e.clientX - rect.left;
        mouseY = e.clientY - rect.top;

        for (const cluster of clusters) {
            let hovering = false;
            for (const b of cluster.bubbles) {
                const dx = mouseX - b.x;
                const dy = mouseY - b.y;
                const dist = Math.hypot(dx, dy);
                if (dist < b.r) {
                    hovering = true;
                    break;
                }
            }

            if (hovering) {
                cluster.hovering = true;
                if (cluster.state === "idle") {
                    cluster.state = "expanding";
                    applyOutwardForce(cluster, WIDTH, HEIGHT);
                    cluster.frameCount = 0;
                }
                if (cluster.revertTimer) {
                    clearTimeout(cluster.revertTimer);
                    cluster.revertTimer = null;
                }
            } else {
                if (cluster.hovering) {
                    cluster.hovering = false;
                    if (!cluster.revertTimer) {
                        cluster.revertTimer = setTimeout(() => {
                            if (!cluster.hovering) {
                                cluster.state = "reverting";
                            }
                        }, REVERT_DELAY);
                    }
                }
            }
        }
    });

    // --- Tooltip update ---
    function updateTooltip() {
        let closest = null;
        let closestDist = Infinity;

        for (const b of singleBubbles) {
            const dx = mouseX - b.x;
            const dy = mouseY - b.y;
            const dist = Math.hypot(dx, dy);
            if (dist < b.r && dist < closestDist && b.showTooltip) {
                closest = b;
                closestDist = dist;
            }
        }
        for (const cluster of clusters) {
            for (const b of cluster.bubbles) {
                const dx = mouseX - b.x;
                const dy = mouseY - b.y;
                const dist = Math.hypot(dx, dy);
                if (dist < b.r && dist < closestDist && b.showTooltip) {
                    closest = b;
                    closestDist = dist;
                }
            }
        }
        if (closest) {
            // Format expiry (date and time)
            let expiry = '';
            let expiryTime = '';
            if (closest.dueTime) {
                const d = new Date(closest.dueTime);
                expiry = d.toLocaleDateString('en-US', { year: 'numeric', month: 'short', day: 'numeric' });
                expiryTime = d.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
            }
            // Format repayment
            const repayment = closest.repayment ? closest.repayment.toLocaleString() : '';
            // --- Calculate Total Due (robust cumulative USD from soonest to hovered loan by due date) ---
            // Only sum over bubbles for the current wallet (allBubbles)
            const valid = allBubbles.filter(b =>
                b.dueTime && !isNaN(new Date(b.dueTime).getTime()) &&
                Number.isFinite(b.repayment) &&
                b.loanId // or another unique identifier
            );
            // Sort by due date ascending, then by loanId (string compare for stability)
            valid.sort((a, b) => {
                const dateDiff = new Date(a.dueTime) - new Date(b.dueTime);
                if (dateDiff !== 0) return dateDiff;
                return String(a.loanId).localeCompare(String(b.loanId));
            });
            // Find hovered loan's index (by loanId)
            const hoveredIndex = valid.findIndex(b => b.loanId === closest.loanId);
            let totalDue = 0;
            if (hoveredIndex !== -1) {
                for (let i = 0; i <= hoveredIndex; i++) {
                    totalDue += valid[i].repayment;
                }
            } else {
                totalDue = Number.isFinite(closest.repayment) ? closest.repayment : 0; // fallback
            }
            // Build HTML
            tooltip.innerHTML = `
                <div class="tooltip-header">
                    <img class="tooltip-img" src="${closest.imageUrl}" alt="NFT" />
                    <div class="tooltip-title">${closest.name || 'NFT Loan'}</div>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Protocol</span>
                    <span class="tooltip-value">${closest.protocol || 'Unknown'}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">APR</span>
                    <span class="tooltip-value">${closest.apr ? closest.apr.toFixed(2) : '--'}%</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Repayment</span>
                    <span class="tooltip-value">${repayment} <span class="tooltip-value usdc">USDC</span></span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Repayment Date</span>
                    <span class="tooltip-value">${expiry} ${expiryTime}</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Total Due</span>
                    <span class="tooltip-value">${totalDue.toLocaleString()} <span class="tooltip-value usdc">USDC</span></span>
                </div>
            `;
            tooltip.style.left = (closest.x + canvas.offsetLeft + 20) + "px";
            tooltip.style.top = (closest.y + canvas.offsetTop - 40) + "px";
            tooltip.style.visibility = "visible";
        } else {
            tooltip.style.visibility = "hidden";
        }
    }

    // --- Add try/catch to wallet change event ---
    walletSelect.addEventListener('change', async (e) => {
        try {
            const selectedWallet = e.target.value;
            if (selectedWallet) {
                const data = await fetchLoanData(selectedWallet);
                if (data && data.data && data.data.length > 0) {
                    useLoanDataForBubbles(
                        data.data,
                        allBubbles,
                        clusters,
                        singleBubbles,
                        clearChart,
                        (bubbles) => findClusters(bubbles, clusters, singleBubbles, bubblesOverlap, VELOCITY_POWER, BASE_VELOCITY),
                        (loan, ...bubbleArgs) => createLoanBubbleFromAPI(loan, ...bubbleArgs),
                        (min, max) => { PADDED_MIN_DATE = min; PADDED_MAX_DATE = max; },
                        MIN_PADDING_PERCENT,
                        MAX_PADDING_PERCENT,
                        CHART_PADDING_X,
                        WIDTH,
                        CHART_PADDING_TOP,
                        CHART_HEIGHT,
                        BUBBLE_PADDING_FACTOR
                    );
                } else {
                    clearChart();
                    console.warn('API response: no loans', data);
                }
            }
        } catch (err) {
            clearChart();
            console.error('Error loading wallet data:', err);
        }
    });

    // --- D3-based Circle Packing for Cluster Expansion ---
    // Helper to pack a cluster's bubbles using d3.packSiblings
    function packClusterBubbles(cluster) {
        // d3.packSiblings expects an array of objects with x, y, r
        // We'll use the current radii, and pack around (0,0)
        const packed = cluster.bubbles.map(b => ({...b, x: 0, y: 0, r: b.r}));
        d3.packSiblings(packed);
        // Compute centroid of the cluster's current positions
        let sumX = 0, sumY = 0;
        for (const b of cluster.bubbles) {
            sumX += b.x;
            sumY += b.y;
        }
        const centroidX = sumX / cluster.bubbles.length;
        const centroidY = sumY / cluster.bubbles.length;
        // Compute bounding box of packed cluster
        const minX = Math.min(...packed.map(b => b.x - b.r));
        const maxX = Math.max(...packed.map(b => b.x + b.r));
        const minY = Math.min(...packed.map(b => b.y - b.r));
        const maxY = Math.max(...packed.map(b => b.y + b.r));
        const packedCenterX = (minX + maxX) / 2;
        const packedCenterY = (minY + maxY) / 2;
        // Offset packed positions to center at the cluster's centroid
        for (let i = 0; i < cluster.bubbles.length; i++) {
            cluster.bubbles[i].packedX = centroidX + (packed[i].x - packedCenterX);
            cluster.bubbles[i].packedY = centroidY + (packed[i].y - packedCenterY);
        }
        // --- Post-packing boundary correction (no scaling) ---
        // Calculate min/max after centering
        let shiftX = 0, shiftY = 0;
        const leftBound = CHART_PADDING_X;
        const rightBound = WIDTH - CHART_PADDING_X;
        const topBound = CHART_PADDING_TOP;
        const bottomBound = CHART_HEIGHT;
        // Find how much we need to shift to keep all bubbles inside bounds
        let minBubbleX = Infinity, maxBubbleX = -Infinity, minBubbleY = Infinity, maxBubbleY = -Infinity;
        for (const b of cluster.bubbles) {
            minBubbleX = Math.min(minBubbleX, b.packedX - b.r);
            maxBubbleX = Math.max(maxBubbleX, b.packedX + b.r);
            minBubbleY = Math.min(minBubbleY, b.packedY - b.r);
            maxBubbleY = Math.max(maxBubbleY, b.packedY + b.r);
        }
        if (minBubbleX < leftBound) shiftX = leftBound - minBubbleX;
        if (maxBubbleX > rightBound) shiftX = rightBound - maxBubbleX;
        if (minBubbleY < topBound) shiftY = topBound - minBubbleY;
        if (maxBubbleY > bottomBound) shiftY = bottomBound - maxBubbleY;
        // Apply the shift to all packed bubbles
        for (const b of cluster.bubbles) {
            b.packedX += shiftX;
            b.packedY += shiftY;
        }
    }

    // Animate bubbles to packed positions
    function animateClusterToPacked(cluster, t) {
        for (const b of cluster.bubbles) {
            b.x += (b.packedX - b.x) * t;
            b.y += (b.packedY - b.y) * t;
        }
    }

    // --- Animation loop ---
    function animate() {
        for (const cluster of clusters) {
            if (cluster.state === "expanding") {
                // On first frame, compute packed positions
                if (!cluster.packedInitialized) {
                    packClusterBubbles(cluster);
                    cluster.packedInitialized = true;
                }
                // Animate bubbles to packed positions
                animateClusterToPacked(cluster, 0.18); // t controls animation speed
                cluster.frameCount++;
                if (cluster.frameCount >= MAX_FRAMES) {
                    cluster.state = "expanded";
                    for (const b of cluster.bubbles) {
                        b.showTooltip = true;
                    }
                }
            } else if (cluster.state === "reverting") {
                revertClusterSmoothly(cluster, WIDTH, HEIGHT);
                cluster.packedInitialized = false;
            }
        }
        draw();
        updateTooltip();
        requestAnimationFrame(animate);
    }

    // Start animation
    animate();

    // --- Responsive Resize Handler ---
    function resizeChart() {
        const container = document.querySelector('.chart-wrapper');
        const containerWidth = container.clientWidth;
        const containerHeight = container.clientHeight;
        const dpr = window.devicePixelRatio || 1;
        canvas.width = Math.round(containerWidth * dpr);
        canvas.height = Math.round(containerHeight * dpr);
        canvas.style.width = containerWidth + 'px';
        canvas.style.height = containerHeight + 'px';
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.scale(dpr, dpr);
        WIDTH = containerWidth;
        HEIGHT = containerHeight;
        CHART_HEIGHT = Math.round(HEIGHT * 0.88);
        CHART_PADDING_X = 24;
        CHART_PADDING_TOP = Math.round(HEIGHT * 0.03);
        CHART_PADDING_BOTTOM = Math.round(HEIGHT * 0.09);
        draw();
    }

    // Remove the aspect ratio function and use container dimensions
    window.addEventListener('resize', resizeChart);
    // Initial set
    resizeChart();

    // Add overlap stats to the animation loop for debugging
    function logOverlapStats() {
        let totalOverlap = 0;
        let maxOverlap = 0;
        let overlapCount = 0;
        for (let i = 0; i < allBubbles.length; i++) {
            for (let j = i + 1; j < allBubbles.length; j++) {
                const b1 = allBubbles[i];
                const b2 = allBubbles[j];
                const overlap = getBubbleOverlap(b1, b2);
                if (overlap > 0) {
                    totalOverlap += overlap;
                    maxOverlap = Math.max(maxOverlap, overlap);
                    overlapCount++;
                }
            }
        }
        console.log(`Total overlap: ${totalOverlap.toFixed(2)}, Max overlap: ${maxOverlap.toFixed(2)}, Overlapping pairs: ${overlapCount}`);
    }
    </script>
</body>
</html> 